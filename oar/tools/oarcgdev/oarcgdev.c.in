#define _GNU_SOURCE

#include <stdlib.h>
#include <errno.h>
#include <assert.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <sys/sysmacros.h>
#include <linux/limits.h>
#include <unistd.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include "oarcgdev-common.h"

#define print_error(MSG, ...) fprintf(stderr, MSG "\n", ##__VA_ARGS__)
#ifndef BPF_PROG_PATH
#define BPF_PROG_PATH "%%OARDIR%%/oarcgdev.bpf"
#endif
#define ARGS_FIRST_DEV 2


/*
 * Usage: oarcgdev <cgroup_path> <dev> [<dev> [<dev> [...]]]
 */
int main(int argc, char **argv)
{
	struct bpf_object *obj;
	struct bpf_program *prog;
	int error = EXIT_FAILURE;
	int cgroup_fd;
	__u64 denykeys[MAP_MAX_DEVS];
	int extra_prog_load_log_flags = 0;

	if (argc < ARGS_FIRST_DEV + 1) {
		print_error("Program requires at least %d parameters", ARGS_FIRST_DEV);
		return error;
	}
	const char* cgroup_path = argv[1];


	for (int i = 0; i < (argc - ARGS_FIRST_DEV); i++) {
		struct stat s;
		if (stat(argv[i + ARGS_FIRST_DEV], &s) == -1) {
			print_error("%s is not a valid device", argv[i + ARGS_FIRST_DEV]);
			return error;
		}
		__u16 type;
		switch (s.st_mode & S_IFMT) {
		case S_IFBLK:
			type = BPF_DEVCG_DEV_BLOCK;
			break;
		case S_IFCHR:
			type = BPF_DEVCG_DEV_CHAR;
			break;
		default:
			print_error("%s is not a block or a character device, other are not supported", argv[i + ARGS_FIRST_DEV]);
			return error;
		}
		denykeys[i] = make_denykey(type, major(s.st_rdev), minor(s.st_rdev));
		/* sanity check: make sure our device encoding respects Linux's one */
		assert((denykeys[i] & ~(0xful << 60)) == s.st_rdev);
	}

	/* Use libbpf 1.0 API mode */
	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);

	LIBBPF_OPTS(bpf_object_open_opts, opts,
		.kernel_log_level = extra_prog_load_log_flags,
	);

	if (!(obj = bpf_object__open_file(BPF_PROG_PATH, &opts))) {
		print_error("Failed to open BPF object");
		return -errno;
	}

	if (!(prog = bpf_object__next_program(obj, NULL))) {
		print_error("Failed to extract BPF program");
		return -errno;
	}

	bpf_program__set_type(prog, BPF_PROG_TYPE_CGROUP_DEVICE);
	if ((error = bpf_object__load(obj))) {
		print_error("Failed to load BPF program");
		error = -errno;
		bpf_object__close(obj);
		return error;
	}

	struct bpf_map *denymap;
	if (!(denymap = bpf_object__find_map_by_name(obj, MAP_NAME_STR))) {
		print_error("Failed to find BPF map");
		error = -errno;
		bpf_object__close(obj);
		return error;
	}

	__u8 denyvalue = 0;
	for (int i = 0; i < (argc - ARGS_FIRST_DEV); i++) {
		if (bpf_map__update_elem(denymap, &denykeys[i], sizeof(denykeys[i]), &denyvalue, sizeof(denyvalue), BPF_ANY)) {
			print_error("Failed to write in BPF map");
			error = -errno;
			bpf_object__close(obj);
			return error;
		}
	}

	cgroup_fd = open(cgroup_path, O_RDONLY);
	if (cgroup_fd < 0) {
		print_error("Failed to open cgroup");
		error = -errno;
		bpf_object__close(obj);
		return error;
	}

	if (bpf_prog_attach(bpf_program__fd(prog), cgroup_fd, BPF_CGROUP_DEVICE, BPF_F_ALLOW_MULTI)) {
		print_error("Failed to attach DEV_CGROUP program");
		error = -errno;
		bpf_object__close(obj);
		return error;
	}

	error = 0;
    bpf_object__close(obj);
	return error;
}
